---
title: "cs_20230412"
output: html_document
date: "2023-04-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

April 12 2023 

RSA
(Our first deployable cryptography algorithm) 

Last week we did this: 

```{r}
textToNum <- function(s)
{
  val = substring(s,1,1)
  val = utf8ToInt(val)
  cs  = nchar(s)
  if (cs > 1)
  {
    rst = substring(s,2,cs)
    rst = textToNum(rst)
    val = val + 0x100 *  
  }
  return(val)
}

#we have a string and we want to turn into a number 
#we turn a part of that string into a number, and then smoosh those together #for a string of length greater than one 
#val = number 
# rst = rest of string 


```

```{r}
textToNum <- function(s)
{
  cs = nchar(s)
  v  = substring(s,1,1)
  v  = utf8ToInt(v)
  if (cs > 1)
  {
    r = substring(s,2,cs)
    r = textToNum(r)
    v = v + 0x100 * r
  }
  return(v)
}


textToNum('hello')
```

```{r}
textToNum <- function(s)
{
  cs = nchar(s)
  v  = substring(s,cs,cs)
  v  = utf8ToInt(v)
  if (cs > 1)
  {
    r = substring(s,1,cs-1)
    r = textToNum(r)
    v = v + 0x100 * r
  }
  return(v)
}

textToNum('hello')
```

```{r}
textToNum <- function(s)
{
  vn = 0
  cs = nchar(s)
  while (cs) {
    vs = substring(s,1,1)
    vn = vn * 0x100
    vn = vn + utf8ToInt(vs)
    s  = substring(s,2,cs)
    cs = nchar(s)
  }
  return(v)
}

textToNum('hello')
```

```{r}
textToNum <- function(s)
{
  cs = nchar(s)
  v  = substring(s,1,1)
  v  = utf8ToInt(v)
  if (cs > 1)
  {
    r = substring(s,2,cs)
    r = textToNum(r)
    v = v + 0x100 * r
  }
  return(v)
}
```

```{r}
numToText <- function(n)
{
  !n && return() #if n = 0, return nothing 
  v = n %% 0x100
  r = n /  0x100
  r = floor(r)
  v = intToUtf8(v)
  r = numToText(r)
  return(paste0(v,r))
}


```

```{r}
numToText <- function(n)
{
  !n && return()
  v = n %% 0x100
  r = n /  0x100
  r = floor(r)
  v = intToUtf8(v)
  r = numToText(r)
  return(paste0(r,v))
}

numToText <- function(n)
{
  !n && return()
  v = n %% 0x100
  r = n %/%  0x100
  r = floor(r)
  v = intToUtf8(v)
  r = numToText(r)
  return(paste0(v,r))
}
```

Written iteratively:
```{r}

numToText <- function(n)
{
  s = ''
  while (n) 
  {
    v = n %% 0x100
    n = n /  0x100
    n = floor(n)
    v = intToUtf8(v)
    s = paste0(v,s)
  }
  return(s)
}
```

```{r}
cs = nchar('string')

?nchar()
```

```{r}
tail <- function(s)
{
  return(substring(s,2,nchar(s)))
}

typeof(floor(145.34))

as.integer(floor(2.5))

typeof(floor(2.5))
```

A public-key cryptosystem is a technique to convert message of up to fixed size (that is, with a maximum value) to "cyphertext" - a numerical value that contains the information of a message, but not in a readable manner. To be a public-key system, any agent must be able to produce cyphertexts, but only the intended receiver may extract the original message from the cyper text.

```{r}
encrypt <- function(s, e)
{
  return(textToNum(s) ^ e)
}

decrypt <- function(s, d, n)
{
  v = (s ^ d) %% n
  return(numtoText(v))
}


```

write a function that makes prime numbers ( that is only divisible by 1 and itself). 

### warm-up: function that prints all the factors of the numbers 
```{r}
factor_finder = function(x)
{
  for (i in 1:x)
  {
    if((x %% i) == 0)
    {
      print(i)
    }
  }
}

factor_finder(100)
```
# function that generates a a prime number 

```{r}
is_prime = function(n) 
{
  factor_num = list()
  for (i in 1:n)
  {
    if((n %% i) == 0)
    {
      factor_num = append(factor_num,i)
    }
  }
  
    if(length(factor_num) == 2)
    {
        return(TRUE)
    }
    else
    {
      return(FALSE)
    }
}


get_prime = function()
{
  prime_check = FALSE 
  while(prime_check == FALSE)
  {
   x = sample(1:1000,1)
   prime_check = is_prime(x)
   if(prime_check)
    {
      return(x)
    }
  }
}

#testing get_prime() 
get_prime()

```

# least common multiple 

```{r}
lcm = function(x,y)
{
  big = max(x,y)
  little = min(x,y)
  multiple = big
  while(multiple %% little != 0)
  {
    multiple = multiple + big
  }
  return(multiple)
}
  
#check
lcm(6,8)
```

## calvin's primarily function:  
```{r}
primality <- function(n) 
{
  i = 2
  while (i < n)
  {
    if (n %% i == 0)
    {
      return(FALSE)
    }
    i = i + 1
  }
  return(TRUE)
}

#For each integer i in this range, the function checks whether n is divisible by i using the modulo operator (%%). If n is found to be divisible by any number in this range, it cannot be prime and the function returns FALSE.

primality(71)

71 %% 2
```


## Co-primality 

Two numbers are co-prime if they do not have any common factors other than 1.
```{r}
coprimality <- function(n,m) 
{
  i = 2
  while (i < n && i < m)
  {
    if (n %% i == 0 && m %% i == 0)
    {
      return(FALSE)
    }
    i = i + 1
  }
  return(TRUE)
}



coprimality(3,4)
```


```{r}
if(gcd)
```


** this works 
```{r}
primality <- function(n) 
{
  for (i in 2:sqrt(n))
  {
    n %% i == 0 && return(FALSE)
  }
  return(TRUE)
}

primality(7)
```

## greatest common denominator 
gcd = the highest number that divides all the given integers.
```{r}
gcd <- function(n, m)
{
  a = max(n,m)
  b = min(n,m)
  if (b == 0)
  {
    return(a)
  }
  return(gcd(b, a %% b))
}

gcd(3,7)
```



```{r}
coprimality <- function(n,m) 
{
  return(gcd(n,m)==1)
}

coprimality(5,7)
```

```{r}
lambda <- function(p, q) 
{
  lcm <- function(n, m)
  lcm(p - 1, q - 1)
}

lambda(p,q)
```

# KEY GENERATION 

1. Compute two prime numbers p and q: 
```{r}
p = get_prime()
q = get_prime()
```

2. Compute the product of these primes n: 
```{r}
n = p*q 
```

3. Compute λ(n) "Carmichael's totient function"
```{r}

```

4. Compute a value e co-prime with λ(n)
```{r}

```


5. Compute d, the modular multiciplicate inverse of e modulo λ(n)
```{r}

```

